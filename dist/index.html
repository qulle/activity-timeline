<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, user-scalable=1">
        <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='rgb(59, 67, 82)' class='bi bi-diagram-3-fill' viewBox='0 0 16 16'%3E%3Cpath fill-rule='evenodd' d='M6 3.5A1.5 1.5 0 0 1 7.5 2h1A1.5 1.5 0 0 1 10 3.5v1A1.5 1.5 0 0 1 8.5 6v1H14a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-1 0V8h-5v.5a.5.5 0 0 1-1 0V8h-5v.5a.5.5 0 0 1-1 0v-1A.5.5 0 0 1 2 7h5.5V6A1.5 1.5 0 0 1 6 4.5v-1zm-6 8A1.5 1.5 0 0 1 1.5 10h1A1.5 1.5 0 0 1 4 11.5v1A1.5 1.5 0 0 1 2.5 14h-1A1.5 1.5 0 0 1 0 12.5v-1zm6 0A1.5 1.5 0 0 1 7.5 10h1a1.5 1.5 0 0 1 1.5 1.5v1A1.5 1.5 0 0 1 8.5 14h-1A1.5 1.5 0 0 1 6 12.5v-1zm6 0a1.5 1.5 0 0 1 1.5-1.5h1a1.5 1.5 0 0 1 1.5 1.5v1a1.5 1.5 0 0 1-1.5 1.5h-1a1.5 1.5 0 0 1-1.5-1.5v-1z'/%3E%3C/svg%3E" type="image/svg+xml">
        <title>Activity Timeline</title>
    </head>
    <body>
        <!-- Inline-style when bundling to single html file -->
        <style>* {
  box-sizing: border-box;
  outline: none;
}

html {
  -ms-overflow-style: none;
  scrollbar-width: none;
}

html::-webkit-scrollbar {
  display: none;
}

body {
  user-select: none;
  margin: 0;
  font-family: Arial, sans-serif;
}

p {
  font-size: 1.125rem;
}

.at-m-0 {
  margin: 0;
}

.at-link {
  color: #6397c2;
  text-decoration: none;
}

.at-link:focus {
  text-decoration: underline;
}

.at-animations--bounce {
  animation: at-bounce .25s forwards;
}

@keyframes at-bounce {
  0% {
    opacity: .6;
    transform: scale(.95);
  }

  50% {
    opacity: .8;
    transform: scale(1.05);
  }

  100% {
    opacity: 1;
    transform: scale(1);
  }
}

.at-canvas {
  display: block;
}

.at-canvas--highlight {
  background-color: #c9e2f3;
  transition: background-color .1s ease-in-out;
}

.at-context-menu {
  max-width: 250px;
  min-width: 200px;
  user-select: none;
  text-shadow: 1px 1px #0000001a;
  background-color: #f6f6f6;
  border-radius: 4px;
  margin: 0;
  padding: 0;
  font-size: .875rem;
  list-style: none;
  display: none;
  position: fixed;
  box-shadow: 1px 1px #0003;
}

.at-context-menu__item {
  cursor: pointer;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: #3b4352;
  border-radius: 4px;
  align-items: center;
  margin: .25rem;
  padding: .563rem .875rem .563rem .5rem;
  transition: background-color .1s ease-in-out;
  display: flex;
  overflow: hidden;
}

.at-context-menu__item:hover, .at-context-menu__item:focus {
  color: #0166a5;
  background-color: #c9e2f3;
}

.at-context-menu__icon {
  filter: drop-shadow(1px 1px #0000001a);
  margin: 0;
  padding-right: .625rem;
  display: flex;
}

.at-context-menu__icon svg {
  width: 20px;
  height: 20px;
}

.at-context-menu--show {
  display: block;
}

.at-modal-backdrop {
  width: 100%;
  height: 100%;
  z-index: 900;
  text-align: center;
  background-color: #0009;
  display: block;
  position: absolute;
  top: 0;
  left: 0;
  overflow-y: auto;
}

.at-modal-backdrop--fixed {
  position: fixed;
}

.at-modal {
  text-align: left;
  max-width: 1350px;
  min-width: 450px;
  background-color: #fff;
  border-radius: 4px;
  margin: 2rem 1rem;
  padding: 1.5rem;
  display: inline-block;
  box-shadow: 1px 1px #0000004d;
}

.at-modal__header {
  place-content: center space-between;
  margin-bottom: 1rem;
  display: flex;
}

.at-modal__title {
  color: #3b4352;
  align-items: center;
  margin: 0;
  display: flex;
}

.at-modal__close {
  color: #3b4352;
  width: 1.75rem;
  height: 1.75rem;
  border-radius: 4px;
  justify-content: center;
  align-items: center;
  margin: 0;
  display: flex;
}

.at-modal__content {
  color: #3b4352;
}

.at-modal__content > :last-child {
  margin-bottom: 0;
}

@media only screen and (max-width: 576px) {
  .at-modal {
    min-width: calc(100% - 2rem);
  }
}

.at-dialog-backdrop {
  width: 100%;
  height: 100%;
  z-index: 900;
  text-align: center;
  background-color: #0009;
  position: absolute;
  top: 0;
  left: 0;
}

.at-dialog-backdrop--fixed {
  position: fixed;
}

.at-dialog {
  max-width: 90%;
  color: #3b4352;
  background-color: #fff;
  border-radius: 4px;
  margin: 2rem auto;
  padding: 1.5rem;
  display: inline-block;
  box-shadow: 1px 1px #0000004d;
}

.at-dialog__input {
  width: 250px;
  margin-bottom: 1rem;
}

.at-dialog__btn {
  padding: .5rem .625rem;
}

.at-dialog__btn:last-child {
  margin-left: .5rem;
}

.at-dialog__btn:only-child {
  margin: 0;
}

.at-canvas {
  display: block;
}

.at-canvas--highlight {
  background-color: #c9e2f3;
  transition: background-color .1s ease-in-out;
}

.at-btn {
  text-align: center;
  user-select: none;
  cursor: pointer;
  color: #fff;
  text-shadow: 1px 1px #0000001a;
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
  -khtml-user-select: none;
  background-color: #0000;
  border: none;
  border-radius: 4px;
  justify-content: center;
  align-items: center;
  padding: .5rem;
  font-size: 1rem;
  font-weight: 400;
  display: inline-flex;
  box-shadow: 1px 1px #0003;
}

.at-btn:focus {
  -webkit-tap-highlight-color: transparent;
  -ms-touch-action: manipulation;
  touch-action: manipulation;
  outline: none;
}

.at-btn--blank {
  box-shadow: none;
  color: #3b4352;
  padding: 0;
}

.at-btn--blank:focus {
  box-shadow: 0 0 0 3px #959dad80;
}

.at-btn--blue-mid {
  background-color: #6397c2;
}

.at-btn--blue-mid:focus {
  box-shadow: 0 0 0 3px #6397c280;
}



</style>

        <canvas id="activity-timeline" class="at-canvas" tabindex="0"></canvas>

        <!-- Inline-js when bundling to single html file -->
        <script>// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"iHUTf":[function(require,module,exports) {
"use strict";
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "fe43b14b346f1550";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, globalThis, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: mixed;
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData,
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData = undefined;
}
module.bundle.Module = Module;
var checkedAssets, acceptedAssets, assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/"); // Web extension context
    var extCtx = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome; // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    } // $FlowFixMe
    ws.onmessage = async function(event) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        acceptedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        var data = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH); // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear(); // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                for(var i = 0; i < assetsToAccept.length; i++){
                    var id = assetsToAccept[i][1];
                    if (!acceptedAssets[id]) hmrAcceptRun(assetsToAccept[i][0], id);
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          🚨 ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>📝 <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", link.getAttribute("href").split("?")[0] + "?" + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension bugfix for Chromium
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {
                        if (typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                            extCtx.runtime.reload();
                            return;
                        }
                        asset.url = extCtx.runtime.getURL("/__parcel_hmr_proxy__?url=" + encodeURIComponent(asset.url + "?t=" + Date.now()));
                        return hmrDownload(asset);
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
             // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id1) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id1]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id1][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id1];
        delete bundle.cache[id1]; // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id1);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToAccept.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) return true;
}
function hmrAcceptRun(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData;
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData);
    });
    delete bundle.cache[id];
    bundle(id);
    cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) // $FlowFixMe[method-unbinding]
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
    });
    acceptedAssets[id] = true;
}

},{}],"8SNpy":[function(require,module,exports) {
var _mainTs = require("./ts/main.ts");

},{"./ts/main.ts":"4j3ZX"}],"4j3ZX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _timeline = require("./modules/Timeline");
var _timelineDefault = parcelHelpers.interopDefault(_timeline);
/**
 * Initiate Timeline instance
 * This will render the landing page
 */ const timelineElement = document.getElementById("activity-timeline");
const timeline = new (0, _timelineDefault.default)(timelineElement);

},{"./modules/Timeline":"hDJ3n","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hDJ3n":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _dataDefault = require("../defaults/data.default");
var _zoomDefault = require("../defaults/zoom.default");
var _positionDefault = require("../defaults/position.default");
var _constantsDefault = require("../defaults/constants.default");
var _contextmenu = require("./contextmenu/Contextmenu");
var _contextmenuDefault = parcelHelpers.interopDefault(_contextmenu);
var _modal = require("./modal/Modal");
var _modalDefault = parcelHelpers.interopDefault(_modal);
var _alert = require("./dialog/Alert");
var _alertDefault = parcelHelpers.interopDefault(_alert);
// Get version information from package.json
const VERSION = require("/package.json").version;
// Reference to target element used when panning the canvas
const SCROLLABLE_TARGET = document.documentElement;
/**
 * Class to render Timeline on a HTMLCanvasElement
 */ class Timeline {
    constructor(canvas){
        this.canvas = canvas;
        this.isDragging = false;
        this.zoom = (0, _zoomDefault.DefaultZoom);
        this.dragPosition = (0, _positionDefault.DefaultPosition);
        this.zoomPosition = (0, _positionDefault.DefaultPosition);
        this.contextmenu = new (0, _contextmenuDefault.default)(this);
        // Set default language and style, can be overridden from the JSON-files
        this.meta = (0, _dataDefault.DefaultData).meta;
        this.style = (0, _dataDefault.DefaultData).style;
        // Disable default browser behaviour
        document.addEventListener("wheel", this.onEventPrevent, {
            passive: false
        });
        document.addEventListener("contextmenu", this.onEventPrevent, {
            passive: false
        });
        this.canvas.addEventListener("drop", this.onDrop.bind(this));
        this.canvas.addEventListener("click", this.onClick.bind(this));
        this.canvas.addEventListener("wheel", this.onMouseWheelZoom.bind(this));
        this.canvas.addEventListener("keydown", this.onKeyDown.bind(this));
        this.canvas.addEventListener("mousemove", this.onMouseMove.bind(this));
        this.canvas.addEventListener("mousedown", this.onMouseDown.bind(this));
        this.canvas.addEventListener("contextmenu", this.onContextmenu.bind(this));
        // Prevent default drag behavior
        [
            "dragenter",
            "dragover",
            "dragleave",
            "drop",
            "contextmenu"
        ].forEach((eventName)=>{
            this.canvas.addEventListener(eventName, this.onEventPrevent);
        });
        // Highlight drop area when item is dragged over it
        [
            "dragenter",
            "dragover"
        ].forEach((eventName)=>{
            this.canvas.addEventListener(eventName, this.highlight.bind(this));
        });
        // Remove highlight background when file leaves or is dropped
        [
            "dragleave",
            "drop"
        ].forEach((eventName)=>{
            this.canvas.addEventListener(eventName, this.unhighlight.bind(this));
        });
        // Re-render canvas if the window is resized
        window.addEventListener("resize", this.onResize.bind(this));
        // Render the landing page as the default screen
        this.renderLandingPage();
        // Set focus to enable keybord inputs
        this.canvas.focus();
    }
    // --------------------------------------------------------------
    // Event methods
    // --------------------------------------------------------------
    /**
     * Prevent Browser default behaviour and propagation
     * @param event General Event
     */ onEventPrevent(event) {
        event.preventDefault();
        event.stopPropagation();
    }
    /**
     * MouseDown EventListener
     * @param event MouseEvent
     */ onMouseDown(event) {
        this.dragPosition = {
            left: SCROLLABLE_TARGET.scrollLeft,
            top: SCROLLABLE_TARGET.scrollTop,
            x: event.clientX,
            y: event.clientY
        };
        // Store references to these events to be able to remove them later
        this.mouseDragCallback = this.onMouseDragHandler.bind(this);
        this.mouseUpCallback = this.onMouseUpHandler.bind(this);
        this.canvas.addEventListener("mousemove", this.mouseDragCallback);
        this.canvas.addEventListener("mouseup", this.mouseUpCallback);
    }
    /**
     * MouseMove EventListener
     * @param event MouseEvent
     */ onMouseDragHandler(event) {
        this.canvas.style.cursor = "grabbing";
        this.isDragging = true;
        // How far the mouse has been moved
        const dx = event.clientX - this.dragPosition.x;
        const dy = event.clientY - this.dragPosition.y;
        // Scroll the element
        SCROLLABLE_TARGET.scrollLeft = this.dragPosition.left - dx;
        SCROLLABLE_TARGET.scrollTop = this.dragPosition.top - dy;
    }
    /**
     * KeyDown EventListener - Return to home location if h-key is pressed
     * @param event KeybordEvent
     */ onKeyDown(event) {
        if (!this.hasData()) return;
        const key = event.key.toLowerCase();
        const commands = {
            s: this.scrollTimeline.bind(this, "start"),
            e: this.scrollTimeline.bind(this, "end"),
            z: this.resetZoom.bind(this)
        };
        commands[key]?.call();
    }
    /**
     * MouseMove EventListener
     * @param event MouseEvent
     */ onMouseMove(event) {
        const activity = this.hitDetection(event.clientX, event.clientY);
        const cursor = activity ? "pointer" : "default";
        this.canvas.style.cursor = cursor;
    }
    /**
     * WheelEvent EventListener - Zooms and re-renders the canvas
     * @param event WheelEvent
     */ onMouseWheelZoom(event) {
        // Disable default vertical scroll of canvas
        event.preventDefault();
        event.stopPropagation();
        // Don't zoom the landing page and only zoom if ctrlKey is down
        if (!this.hasData() || !event.ctrlKey) return;
        this.zoomTimeline(event.deltaY);
    }
    /**
     * Handles all click events on the canvas
     * The coordinates are checked against the plotted activities to display modal window for the correct activity
     * @param event Browser DragEvent
     */ onClick(event) {
        this.contextmenu.hide();
        // Check if the canvas was dragged
        // If so reset the bit and exit this event since it was not intended as a click on an activity
        if (this.isDragging) {
            this.isDragging = false;
            return;
        }
        const activity = this.hitDetection(event.clientX, event.clientY);
        if (activity) {
            const title = `
                <span style="
                    width: 20px;
                    height: 20px;
                    border-radius: 50%;
                    margin-right: 0.5rem;
                    flex-shrink: 0;
                    background-color: ${activity.fillColor};
                    border: 2px solid ${activity.strokeColor};
                "></span>
                ${activity.title}
            `;
            const content = `
                <p>${activity.description}</p>
                <p>${activity.timestamp.toLocaleString(this.meta.locale)}</p>
            `;
            const modal = new (0, _modalDefault.default)(title, content);
        }
    }
    /**
     * MouseUp EventListene
     */ onMouseUpHandler() {
        this.canvas.removeEventListener("mousemove", this.mouseDragCallback);
        this.canvas.removeEventListener("mouseup", this.mouseUpCallback);
        this.canvas.style.cursor = "default";
    }
    /**
     * When a file is dropped on the canvas
     * @param event Browser DragEvent
     */ onDrop(event) {
        const dataTransfer = event.dataTransfer;
        const files = dataTransfer.files;
        // Can only parse and display one file at the time
        // Take the first file that was dropped
        const firstFile = files.item(0);
        this.filename = firstFile.name.substring(0, firstFile.name.lastIndexOf(".")) || firstFile.name;
        this.parseFile(firstFile);
    }
    /**
    * Triggered by event when the window is resized
    */ onResize() {
        if (this.hasData()) this.render();
        else this.renderLandingPage();
    }
    /**
     * Contextmenu event to show the custom contextmenu
     * @param event MouseEvent
     */ onContextmenu(event) {
        if (this.hasData()) this.contextmenu.show(event);
    }
    // --------------------------------------------------------------
    // Logical methods
    // --------------------------------------------------------------
    /**
     * Callback function from Contextmenu - Exports Timeline as PNG
     */ contextmenuOnExportPNG() {
        const dataURL = this.canvas.toDataURL("image/png", 1.0);
        const download = document.createElement("a");
        download.href = dataURL;
        download.download = this.filename + ".png";
        document.body.appendChild(download);
        download.click();
        document.body.removeChild(download);
    }
    /**
     * Callback function from Contextmenu - Displays About information
     */ contextmenuOnAbout() {
        const about = new (0, _alertDefault.default)(`
            <h3 class="at-m-0">Version ${VERSION}</h3>
            <p>Developed by Qulle</p>
            <p><a href="//github.com/qulle/activity-timeline" target="_blank" class="at-link">github.com/qulle/activity-timeline</a></p>
        `);
    }
    /**
     * Callback function from Contextmenu - Zooms in
     */ contextmenuOnZoomIn() {
        this.zoomTimeline(-1);
    }
    /**
     * Callback function from Contextmenu - Zooms out
     */ contextmenuOnZoomOut() {
        this.zoomTimeline(1);
    }
    /**
     * Zoom in or out
     * @param deltaY 1 = Zoom out, -1 = Zoom in
     */ zoomTimeline(deltaY) {
        // Adjust the zoom-value based on the deltaY value
        if (deltaY < 0 && this.zoom.value * this.zoom.factor < this.zoom.max) this.zoom.value *= this.zoom.factor;
        else if (deltaY > 0 && this.zoom.value / this.zoom.factor > this.zoom.min) this.zoom.value /= this.zoom.factor;
        // Render the Timeline with the new zoom
        this.render();
    // TODO: Adjust zoom to mouse location
    }
    /**
     * Scroll Timeline to vertical center and horizontal discrete location
     * @param inline 'center' | 'end' | 'nearest' | 'start'
     */ scrollTimeline(inline) {
        this.canvas.scrollIntoView({
            behavior: "smooth",
            block: "center",
            inline: inline
        });
    }
    /**
     * Resets zoom level to standard and re-renders Timeline
     */ resetZoom() {
        this.zoom.value = 1;
        this.render();
    }
    /**
     * Highlight drop area when item is dragged over it
     */ highlight() {
        this.canvas.classList.add("at-canvas--highlight");
    }
    /**
     * Remove highlight background when file leaves or is dropped
     */ unhighlight() {
        this.canvas.classList.remove("at-canvas--highlight");
    }
    /**
     * Parse the given file that was dropped and render the Timeline
     * @param file The file that was dropped
     */ parseFile(file) {
        const self = this;
        const reader = new FileReader();
        reader.readAsText(file);
        reader.onloadend = function() {
            let currentDate;
            try {
                // Parse the JSON-file and convert date and timestamps to date objects using the reviever function
                const data = JSON.parse(reader.result, function(key, value) {
                    if (key === "date") {
                        currentDate = value;
                        value = new Date(value);
                    } else if (key === "timestamp") value = new Date(currentDate + " " + value);
                    return value;
                });
                self.setData(data);
                self.render();
                // Scroll last day into viewport
                self.scrollTimeline("end");
            } catch (error) {
                const alert = new (0, _alertDefault.default)("<p>Error parsing the JSON file, check the syntax!</p>");
            }
        };
    }
    /**
     * Check if the data array has data to render
     * @returns True if array holds data, False otherwise
     */ hasData() {
        return Array.isArray(this.days);
    }
    /**
     * Calculates the width of the canvas base on the data to be rendered
     * @returns Width of the canvas, minimum width is the window.innerWidth
     */ calculateWidth() {
        // window.innerWidth is the minimum width of the canvas
        let width = window.innerWidth;
        const calculatedWidth = (0, _constantsDefault.DefaultConstants).xPadding + (0, _constantsDefault.DefaultConstants).stepDistanceXAxis * (0, _constantsDefault.DefaultConstants).amplification * this.days.length * this.zoom.value;
        if (calculatedWidth > width) width = calculatedWidth;
        return width;
    }
    /**
     * Calculates the height of the canvas base on the data to be rendered
     * @returns Height of the canvas, minimum height is the window.innerHeight
     */ calculateHeight() {
        // window.innerHeight is the minimum height of the canvas
        let height = window.innerHeight;
        let maxActivitiesOnYAxis = 0;
        // Find the day with most activites to be rendered on the Y-axis
        this.days.forEach((day)=>{
            if (day.activities.length > maxActivitiesOnYAxis) maxActivitiesOnYAxis = day.activities.length;
        });
        // Calculate appropriate height
        const calculatedHeight = (0, _constantsDefault.DefaultConstants).yPadding + (0, _constantsDefault.DefaultConstants).stepDistanceYAxis * maxActivitiesOnYAxis * 2 * this.zoom.value;
        if (calculatedHeight > height) height = calculatedHeight;
        return height;
    }
    /**
     * Calculates the Y-coordinate for where to render the X-axis
     * @returns Y-coordinate for where to render the X-axis
     */ getVerticalMid() {
        return (this.canvas.height / 2 - this.style.lineThickness / 2) / this.zoom.value;
    }
    /**
     * Check if date is todays date
     * @param date Value to be checked
     * @returns True if date is today otherwise False
     */ isToday(date) {
        const now = new Date();
        return date.getFullYear() === now.getFullYear() && date.getMonth() === now.getMonth() && date.getDate() === now.getDate();
    }
    /**
     * Gets the long version of weekday from a given date
     * @param date Value to be converted to weekday
     * @returns Weekday in format [Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday]
     */ getWeekDayName(date) {
        // Translate date to weekday name
        const weekDay = date.toLocaleString(this.meta.locale, {
            weekday: "long"
        });
        // Make the first letter capialized
        return weekDay.charAt(0).toUpperCase() + weekDay.slice(1);
    }
    /**
     * Checks direction to render activities on the Y-axis
     * @param index Iterator-index from loop
     * @returns True if rendering towards top, False if towards bottom
     */ isTop(index) {
        return index % 2 === 0;
    }
    /**
     * Get the Activity that corresponds to the clicked location in the canvas
     * @param x X-coordinate
     * @param y Y-coordinate
     * @returns The clicked Activity, undefined if no activity is found
     */ hitDetection(x, y) {
        if (!this.hasData()) return undefined;
        // The coordinates must be translated to accommodate for scrolling in the canvas
        const rect = this.canvas.getBoundingClientRect();
        const relX = (x - rect.left) / this.zoom.value;
        const relY = (y - rect.top) / this.zoom.value;
        // How far the detection will be checked away from the clicked coordinate
        const tolerance = (0, _constantsDefault.DefaultConstants).radius;
        // TODO: Big O - Time Complexity, make it more efficient using another data structure
        for(let a = 0; a < this.days.length; a++)for(let b = 0; b < this.days[a].activities.length; b++){
            const activity = this.days[a].activities[b];
            if (activity.x >= relX - tolerance && activity.x <= relX + tolerance && activity.y >= relY - tolerance && activity.y <= relY + tolerance) return activity;
        }
        return undefined;
    }
    /**
     * Sets the data to be rendered on the Timeline
     * Sorts both days and activites in ascending order
     * @param data Array of days to be rendered
     */ setData(data) {
        // Override default data with data from the JSON-file
        this.meta = {
            ...(0, _dataDefault.DefaultData).meta,
            ...data.meta
        };
        this.style = {
            ...(0, _dataDefault.DefaultData).style,
            ...data.style
        };
        this.days = [
            ...(0, _dataDefault.DefaultData).days,
            ...data.days
        ];
        // Sort days in ascending order
        this.days.sort((left, right)=>{
            return left.date.getTime() - right.date.getTime();
        });
        // Sort activities in each day in ascending order
        this.days.forEach((day)=>{
            day.activities.sort((left, right)=>{
                return left.timestamp.getTime() - right.timestamp.getTime();
            });
        });
    }
    // --------------------------------------------------------------
    // Render methods
    // --------------------------------------------------------------
    /**
     * Renders a circle in the canvas at a given coordinate
     * @param ctx HTMLCanvas 2d-context
     * @param x X-coordinate 
     * @param y Y-cordinate
     * @param radius Radius of the circle
     * @param fillColor Fillcolor of the circle
     * @param strokeColor Strokecolor of the circle
     */ renderCircle(ctx, x, y, radius, fillColor, strokeColor) {
        ctx.fillStyle = fillColor;
        ctx.strokeStyle = strokeColor;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
    }
    /**
     * Renders the landing page when the app is first started
     */ renderLandingPage() {
        // Context to render elements on
        const ctx = this.canvas.getContext("2d");
        // Default canvas size same as window
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        // Clear the canvas
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        // Calculate appropriate dimensions for the drop square
        const dropSquareWidth = window.innerWidth < (0, _constantsDefault.DefaultConstants).ladingPageWidth + (0, _constantsDefault.DefaultConstants).canvasInternalPadding ? 0.9 * window.innerWidth : (0, _constantsDefault.DefaultConstants).ladingPageWidth;
        const dropSquareHeight = window.innerHeight < (0, _constantsDefault.DefaultConstants).ladingPageHeight + (0, _constantsDefault.DefaultConstants).canvasInternalPadding ? 0.9 * window.innerHeight : (0, _constantsDefault.DefaultConstants).ladingPageHeight;
        // Render drop square
        ctx.fillStyle = "#E9E9E9";
        ctx.lineWidth = this.style.lineThickness;
        ctx.strokeStyle = this.style.strokeColor;
        ctx.setLineDash([
            6
        ]);
        ctx.fillRect(window.innerWidth / 2 - dropSquareWidth / 2, window.innerHeight / 2 - dropSquareHeight / 1.8, dropSquareWidth, dropSquareHeight);
        ctx.strokeRect(window.innerWidth / 2 - dropSquareWidth / 2, window.innerHeight / 2 - dropSquareHeight / 1.8, dropSquareWidth, dropSquareHeight);
        // Note: The Path2D SVG is generated for size 100 * 76
        const dropIconDimensions = {
            width: 100,
            height: 76
        };
        const dropIconSVGPath = new Path2D("M37.5 21.875C37.5 19.3886 38.4877 17.004 40.2459 15.2459C42.004 13.4877 44.3886 12.5 46.875 12.5H53.125C55.6114 12.5 57.996 13.4877 59.7541 15.2459C61.5123 17.004 62.5 19.3886 62.5 21.875V28.125C62.5 30.6114 61.5123 32.996 59.7541 34.7541C57.996 36.5123 55.6114 37.5 53.125 37.5V43.75H87.5C88.3288 43.75 89.1237 44.0792 89.7097 44.6653C90.2958 45.2513 90.625 46.0462 90.625 46.875V53.125C90.625 53.9538 90.2958 54.7487 89.7097 55.3347C89.1237 55.9208 88.3288 56.25 87.5 56.25C86.6712 56.25 85.8763 55.9208 85.2903 55.3347C84.7042 54.7487 84.375 53.9538 84.375 53.125V50H53.125V53.125C53.125 53.9538 52.7958 54.7487 52.2097 55.3347C51.6237 55.9208 50.8288 56.25 50 56.25C49.1712 56.25 48.3763 55.9208 47.7903 55.3347C47.2042 54.7487 46.875 53.9538 46.875 53.125V50H15.625V53.125C15.625 53.9538 15.2958 54.7487 14.7097 55.3347C14.1237 55.9208 13.3288 56.25 12.5 56.25C11.6712 56.25 10.8763 55.9208 10.2903 55.3347C9.70424 54.7487 9.375 53.9538 9.375 53.125V46.875C9.375 46.0462 9.70424 45.2513 10.2903 44.6653C10.8763 44.0792 11.6712 43.75 12.5 43.75H46.875V37.5C44.3886 37.5 42.004 36.5123 40.2459 34.7541C38.4877 32.996 37.5 30.6114 37.5 28.125V21.875ZM0 71.875C0 69.3886 0.98772 67.004 2.74587 65.2459C4.50403 63.4877 6.8886 62.5 9.375 62.5H15.625C18.1114 62.5 20.496 63.4877 22.2541 65.2459C24.0123 67.004 25 69.3886 25 71.875V78.125C25 80.6114 24.0123 82.996 22.2541 84.7541C20.496 86.5123 18.1114 87.5 15.625 87.5H9.375C6.8886 87.5 4.50403 86.5123 2.74587 84.7541C0.98772 82.996 0 80.6114 0 78.125L0 71.875ZM37.5 71.875C37.5 69.3886 38.4877 67.004 40.2459 65.2459C42.004 63.4877 44.3886 62.5 46.875 62.5H53.125C55.6114 62.5 57.996 63.4877 59.7541 65.2459C61.5123 67.004 62.5 69.3886 62.5 71.875V78.125C62.5 80.6114 61.5123 82.996 59.7541 84.7541C57.996 86.5123 55.6114 87.5 53.125 87.5H46.875C44.3886 87.5 42.004 86.5123 40.2459 84.7541C38.4877 82.996 37.5 80.6114 37.5 78.125V71.875ZM75 71.875C75 69.3886 75.9877 67.004 77.7459 65.2459C79.504 63.4877 81.8886 62.5 84.375 62.5H90.625C93.1114 62.5 95.496 63.4877 97.2541 65.2459C99.0123 67.004 100 69.3886 100 71.875V78.125C100 80.6114 99.0123 82.996 97.2541 84.7541C95.496 86.5123 93.1114 87.5 90.625 87.5H84.375C81.8886 87.5 79.504 86.5123 77.7459 84.7541C75.9877 82.996 75 80.6114 75 78.125V71.875Z");
        // Render drop text
        const dropLabel = "DROP TIMELINE JSON { }";
        ctx.font = `italic bold 20px Arial`;
        ctx.fillStyle = this.style.textColor;
        ctx.fillText(dropLabel, window.innerWidth / 2 - ctx.measureText(dropLabel).width / 2, window.innerHeight / 2 + dropIconDimensions.height / 2);
        // Render version text
        const versionLabel = "Version " + VERSION;
        ctx.font = `italic 14px Arial`;
        ctx.fillText(versionLabel, window.innerWidth / 2 - ctx.measureText(versionLabel).width / 2, window.innerHeight / 2 + dropIconDimensions.height / 2 + 20);
        // Render drop icon
        ctx.translate(window.innerWidth / 2 - dropIconDimensions.width / 2, window.innerHeight / 2 - dropIconDimensions.height - 20);
        ctx.fill(dropIconSVGPath);
    }
    /**
     * Renders the Timeline on the canvas based on the given data
     */ render() {
        // Context to render elements on
        const ctx = this.canvas.getContext("2d");
        // Set canvas width and height based no the data
        this.canvas.width = this.calculateWidth();
        this.canvas.height = this.calculateHeight();
        // Clear the canvas
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        // Canvas background
        ctx.fillStyle = this.style.backgroundColor;
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        // Note: This will affect all things that are drawn. 
        // In some places values must be corrected by multiplying or dividing with the zoom.value
        ctx.scale(this.zoom.value, this.zoom.value);
        // Get the mid of the canvas, must come after the calculate width/height
        const mid = this.getVerticalMid();
        // Default style
        ctx.font = `bold ${this.style.fontSize}px Arial`;
        ctx.strokeStyle = this.style.timelineStrokeColor;
        ctx.lineWidth = this.style.lineThickness;
        ctx.lineCap = "round";
        // Render main Timeline
        ctx.beginPath();
        ctx.moveTo((0, _constantsDefault.DefaultConstants).canvasInternalPadding, mid);
        ctx.lineTo(this.canvas.width / this.zoom.value - (0, _constantsDefault.DefaultConstants).canvasInternalPadding, mid);
        ctx.stroke();
        // Render each day on Timeline
        this.days.forEach((day, index1)=>{
            const x = (0, _constantsDefault.DefaultConstants).xPadding + (0, _constantsDefault.DefaultConstants).stepDistanceXAxis * (0, _constantsDefault.DefaultConstants).amplification * index1;
            const y = mid;
            // If placement is top or bottom direction on the Y-axis
            const sign = this.isTop(index1) ? 1 : -1;
            // Adjust for the text height on top positioned text
            const signAdjustment = !this.isTop(index1) ? this.style.fontSize / 2 : 0;
            // Render day Timeline
            ctx.strokeStyle = this.style.timelineStrokeColor;
            ctx.beginPath();
            ctx.setLineDash([
                5,
                8
            ]);
            ctx.moveTo(x, y);
            ctx.lineTo(x, y + day.activities.length * (0, _constantsDefault.DefaultConstants).stepDistanceYAxis * -sign);
            ctx.stroke();
            ctx.setLineDash([]);
            // Render activities from that day
            day.activities.forEach((activity, index)=>{
                // Render activity-circle
                const posX = x;
                const posY = y + (0, _constantsDefault.DefaultConstants).stepDistanceYAxis * (index + 1) * -sign;
                this.renderCircle(ctx, posX, posY, (0, _constantsDefault.DefaultConstants).radius, activity.fillColor, activity.strokeColor);
                // Store coordinates where the activity was rendered, this will be used in the click-event
                activity.x = posX;
                activity.y = posY;
                // Render activity-label
                ctx.fillStyle = this.style.textColor;
                ctx.fillText(activity.title, x + (0, _constantsDefault.DefaultConstants).radius * 1.5, y + (0, _constantsDefault.DefaultConstants).stepDistanceYAxis * (index + 1) * -sign - 10 + this.style.fontSize / 2);
                ctx.fillText(activity.timestamp.toLocaleTimeString(this.meta.locale), x + (0, _constantsDefault.DefaultConstants).radius * 1.5, y + (0, _constantsDefault.DefaultConstants).stepDistanceYAxis * (index + 1) * -sign + 8 + this.style.fontSize / 2);
            });
            // Render date-circle on Timeline
            this.renderCircle(ctx, x, y, (0, _constantsDefault.DefaultConstants).radius, this.style.fillColor, this.style.strokeColor);
            // Render date-label
            const dateLabel = this.isToday(day.date) ? day.date.toLocaleDateString(this.meta.locale) + " (Today)" : day.date.toLocaleDateString(this.meta.locale) + " (" + this.getWeekDayName(day.date) + ")";
            ctx.fillStyle = this.style.textColor;
            ctx.fillText(dateLabel, x - ctx.measureText(dateLabel).width / 2, y + signAdjustment + (0, _constantsDefault.DefaultConstants).radius * 2 * sign);
        });
    }
}
exports.default = Timeline;

},{"../defaults/data.default":"ioA2P","../defaults/zoom.default":"aRmnB","../defaults/constants.default":"88HBh","./modal/Modal":"8MNHj","./dialog/Alert":"ekOfd","/package.json":"dIKiH","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","../defaults/position.default":"k3WBG","./contextmenu/Contextmenu":"1g3Mu"}],"ioA2P":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DefaultData", ()=>DefaultData);
var _metaDefault = require("./meta.default");
var _styleDefault = require("./style.default");
/**
 * Main default object containing the complete object used in the Timeline
 * This object is merged with the loaded JSON-file using the spread operator
 */ const DefaultData = {
    meta: (0, _metaDefault.DefaultMeta),
    style: (0, _styleDefault.DefaultStyle),
    days: []
};

},{"./meta.default":"3onga","./style.default":"4bQA7","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3onga":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DefaultMeta", ()=>DefaultMeta);
/**
 * Default object containing meta information 
 * This data can be overridden from the JSON-file
 * "meta": {
 *     "locale": "sv-se"
 * }
 * "style": {...},
 * "days": [...]
 */ const DefaultMeta = {
    locale: "en-us"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"4bQA7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DefaultStyle", ()=>DefaultStyle);
/**
 * Default object containing style information
 * This data can be overridden from the JSON-file
 * "style": {
 *     "backgroundColor": "#3B4352"
 * },
 * "days": [...]
 */ const DefaultStyle = {
    fontSize: 14,
    lineThickness: 2,
    timelineStrokeColor: "#3B4352",
    strokeColor: "#3B4352",
    fillColor: "#BAC8D3",
    textColor: "#3B4352",
    backgroundColor: "#FFFFFF"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aRmnB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DefaultZoom", ()=>DefaultZoom);
const DefaultZoom = {
    value: 1,
    factor: 1.1,
    min: 0.3,
    max: 1.6
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"88HBh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DefaultConstants", ()=>DefaultConstants);
const DefaultConstants = {
    ladingPageWidth: 600,
    ladingPageHeight: 300,
    radius: 18,
    amplification: 2,
    stepDistanceXAxis: 150,
    stepDistanceYAxis: 80,
    canvasInternalPadding: 20,
    xPadding: 150,
    yPadding: 80
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8MNHj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _modalBase = require("./ModalBase");
var _modalBaseDefault = parcelHelpers.interopDefault(_modalBase);
class Modal extends (0, _modalBaseDefault.default) {
    constructor(title, content){
        super(title);
        const modalContent = document.createElement("div");
        modalContent.className = "at-modal__content";
        modalContent.innerHTML = content;
        this.show(modalContent);
    }
}
exports.default = Modal;

},{"./ModalBase":"6BfDQ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6BfDQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _trapFocus = require("../helpers/TrapFocus");
var _icons = require("../helpers/Icons");
const ANIMATION_CLASS = "at-animations--bounce";
class ModalBase {
    constructor(title){
        const modalBackdrop = document.createElement("div");
        modalBackdrop.className = "at-modal-backdrop at-modal-backdrop--fixed";
        modalBackdrop.setAttribute("tabindex", "1");
        modalBackdrop.addEventListener("keydown", (0, _trapFocus.trapFocusKeyListener));
        modalBackdrop.addEventListener("click", this.bounceAnimation.bind(this));
        const modal = document.createElement("div");
        modal.className = "at-modal at-animations--bounce";
        const modalHeader = document.createElement("div");
        modalHeader.className = "at-modal__header";
        const modalTitle = document.createElement("h3");
        modalTitle.className = "at-modal__title";
        modalTitle.innerHTML = title;
        const modalClose = document.createElement("button");
        modalClose.setAttribute("type", "button");
        modalClose.className = "at-modal__close at-btn at-btn--blank";
        modalClose.innerHTML = (0, _icons.getIcon)({
            path: (0, _icons.SVGPaths).Close,
            fill: "none",
            stroke: "currentColor"
        });
        modalClose.addEventListener("click", (event)=>{
            event.preventDefault();
            this.close();
        });
        modalBackdrop.appendChild(modal);
        modal.appendChild(modalHeader);
        modalHeader.appendChild(modalTitle);
        modalHeader.appendChild(modalClose);
        this.modalBackdrop = modalBackdrop;
        this.modal = modal;
        window.addEventListener("keyup", (event)=>{
            if (event.key === "Escape") this.close();
        });
    }
    bounceAnimation(event) {
        // To prevent trigger the animation if clicked in the modal and not the backdrop
        if (event.target !== this.modalBackdrop) return;
        this.modal.classList.remove(ANIMATION_CLASS);
        this.modal.offsetWidth;
        this.modal.classList.add(ANIMATION_CLASS);
    }
    show(modalContent) {
        this.modal.appendChild(modalContent);
        document.body.appendChild(this.modalBackdrop);
        this.modal.focus();
    }
    close() {
        this.modalBackdrop.removeEventListener("keydown", (0, _trapFocus.trapFocusKeyListener));
        this.modalBackdrop.remove();
    }
}
exports.default = ModalBase;

},{"../helpers/TrapFocus":"2nbVV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","../helpers/Icons":"7YvtL"}],"2nbVV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "trapFocusKeyListener", ()=>trapFocusKeyListener);
const FOCUSABLE_ELEMENTS = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
/**
 * Traps the focus to always stay in the target component
 * @param event KeyboardEvent
 */ const trapFocusKeyListener = function(event) {
    // Component = the modal, alert, confirm etc.
    const component = this;
    const firstFocusableElement = component.querySelectorAll(FOCUSABLE_ELEMENTS)[0];
    const focusableContent = component.querySelectorAll(FOCUSABLE_ELEMENTS);
    const lastFocusableElement = focusableContent[focusableContent.length - 1];
    const isTabPressed = event.key === "Tab";
    if (!isTabPressed) return;
    if (event.shiftKey) {
        if (document.activeElement === firstFocusableElement) {
            lastFocusableElement.focus();
            event.preventDefault();
        }
    } else if (document.activeElement === lastFocusableElement) {
        firstFocusableElement.focus();
        event.preventDefault();
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7YvtL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SVGPaths", ()=>SVGPaths);
parcelHelpers.export(exports, "getIcon", ()=>getIcon);
var _iconDefault = require("../../defaults/icon.default");
const getIcon = function(icon) {
    const options = {
        ...(0, _iconDefault.DefaultIcon),
        ...icon
    };
    return `
        <svg xmlns="http://www.w3.org/2000/svg" 
            width="${options.width}" 
            height="${options.height}" 
            fill="${options.fill}"
            stroke="${options.stroke}" 
            class="${options.class}" 
            viewBox="0 0 16 16">
            ${options.path}
        </svg>
    `;
};
const SVGPaths = {
    Close: `
        <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>
    `,
    Export: `
        <path d="M6.002 5.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0z"/>
        <path d="M2.002 1a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V3a2 2 0 0 0-2-2h-12zm12 1a1 1 0 0 1 1 1v6.5l-3.777-1.947a.5.5 0 0 0-.577.093l-3.71 3.71-2.66-1.772a.5.5 0 0 0-.63.062L1.002 12V3a1 1 0 0 1 1-1h12z"/>
    `,
    GitHub: `
        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"/>
    `,
    ZoomIn: `
        <path fill-rule="evenodd" d="M6.5 12a5.5 5.5 0 1 0 0-11 5.5 5.5 0 0 0 0 11zM13 6.5a6.5 6.5 0 1 1-13 0 6.5 6.5 0 0 1 13 0z"/>
        <path d="M10.344 11.742c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1 6.538 6.538 0 0 1-1.398 1.4z"/>
        <path fill-rule="evenodd" d="M6.5 3a.5.5 0 0 1 .5.5V6h2.5a.5.5 0 0 1 0 1H7v2.5a.5.5 0 0 1-1 0V7H3.5a.5.5 0 0 1 0-1H6V3.5a.5.5 0 0 1 .5-.5z"/>
    `,
    ZoomOut: `
        <path fill-rule="evenodd" d="M6.5 12a5.5 5.5 0 1 0 0-11 5.5 5.5 0 0 0 0 11zM13 6.5a6.5 6.5 0 1 1-13 0 6.5 6.5 0 0 1 13 0z"/>
        <path d="M10.344 11.742c.03.04.062.078.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1.007 1.007 0 0 0-.115-.1 6.538 6.538 0 0 1-1.398 1.4z"/>
        <path fill-rule="evenodd" d="M3 6.5a.5.5 0 0 1 .5-.5h6a.5.5 0 0 1 0 1h-6a.5.5 0 0 1-.5-.5z"/>
    `
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","../../defaults/icon.default":"5OTap"}],"5OTap":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DefaultIcon", ()=>DefaultIcon);
const DefaultIcon = {
    width: 24,
    height: 24,
    fill: "currentColor",
    stroke: "none",
    class: "",
    path: ""
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ekOfd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _dialogBase = require("./DialogBase");
var _dialogBaseDefault = parcelHelpers.interopDefault(_dialogBase);
class Alert extends (0, _dialogBaseDefault.default) {
    constructor(content){
        super();
        const dialog = document.createElement("div");
        dialog.className = "at-dialog at-dialog--alert at-animations--bounce";
        dialog.innerHTML = content;
        const okButton = document.createElement("button");
        okButton.setAttribute("type", "button");
        okButton.className = "at-dialog__btn at-btn at-btn--blue-mid";
        okButton.innerText = "Got it!";
        okButton.addEventListener("click", (event)=>{
            this.close();
        });
        dialog.appendChild(okButton);
        this.dialogBackdrop.appendChild(dialog);
        document.body.appendChild(this.dialogBackdrop);
        this.dialogBackdrop.focus();
    }
}
exports.default = Alert;

},{"./DialogBase":"4UO0t","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4UO0t":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _trapFocus = require("../helpers/TrapFocus");
const ANIMATION_CLASS = "at-animations--bounce";
class DialogBase {
    constructor(){
        const dialogBackdrop = document.createElement("div");
        dialogBackdrop.className = "at-dialog-backdrop at-dialog-backdrop--fixed";
        dialogBackdrop.setAttribute("tabindex", "-1");
        dialogBackdrop.addEventListener("keydown", (0, _trapFocus.trapFocusKeyListener));
        dialogBackdrop.addEventListener("click", this.bounceAnimation.bind(this));
        this.dialogBackdrop = dialogBackdrop;
        window.addEventListener("keyup", (event)=>{
            if (event.key === "Escape") this.close();
        });
    }
    bounceAnimation(event) {
        // To prevent trigger the animation if clicked in the dialog and not the backdrop
        if (event.target !== this.dialogBackdrop) return;
        const dialog = this.dialogBackdrop.firstElementChild;
        dialog.classList.remove(ANIMATION_CLASS);
        dialog.offsetWidth;
        dialog.classList.add(ANIMATION_CLASS);
    }
    close() {
        this.dialogBackdrop.removeEventListener("keydown", (0, _trapFocus.trapFocusKeyListener));
        this.dialogBackdrop.remove();
    }
}
exports.default = DialogBase;

},{"../helpers/TrapFocus":"2nbVV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dIKiH":[function(require,module,exports) {
module.exports = JSON.parse('{"name":"activity-timeline","version":"1.0.0","description":"Portable activity timeline that draws the timeline based on data given in JSON format.","scripts":{"start":"parcel src/index.html --open","build":"parcel build --public-url . src/index.html","clean":"rm -rf dist/","test":"echo \\"Error: no test specified\\" && exit 1"},"keywords":[],"author":"Qulle - https://github.com/qulle","license":"BSD-2-Clause license","devDependencies":{"@parcel/transformer-sass":"^2.6.0","@types/node":"^18.6.1","parcel":"^2.6.0"}}');

},{}],"k3WBG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DefaultPosition", ()=>DefaultPosition);
const DefaultPosition = {
    left: 0,
    top: 0,
    x: 0,
    y: 0
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1g3Mu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _trapFocus = require("../helpers/TrapFocus");
var _icons = require("../helpers/Icons");
class ContextMenu {
    constructor(timeline){
        this.timeline = timeline;
        this.create();
    }
    create() {
        // Create root <ul>
        this.menu = document.createElement("ul");
        this.menu.className = "at-context-menu";
        this.menu.setAttribute("tabindex", "-1");
        this.menu.addEventListener("keydown", (0, _trapFocus.trapFocusKeyListener));
        // Create menu items
        this.addMenuItem("Export as PNG", this.timeline.contextmenuOnExportPNG.bind(this.timeline), (0, _icons.getIcon)({
            path: (0, _icons.SVGPaths).Export,
            fill: "currentColor",
            stroke: "none"
        }));
        this.addMenuItem("Zoom in", this.timeline.contextmenuOnZoomIn.bind(this.timeline), (0, _icons.getIcon)({
            path: (0, _icons.SVGPaths).ZoomIn,
            fill: "currentColor",
            stroke: "none"
        }));
        this.addMenuItem("Zoom out", this.timeline.contextmenuOnZoomOut.bind(this.timeline), (0, _icons.getIcon)({
            path: (0, _icons.SVGPaths).ZoomOut,
            fill: "currentColor",
            stroke: "none"
        }));
        this.addMenuItem("About", this.timeline.contextmenuOnAbout.bind(this.timeline), (0, _icons.getIcon)({
            path: (0, _icons.SVGPaths).GitHub,
            fill: "currentColor",
            stroke: "none"
        }));
        document.body.appendChild(this.menu);
    }
    addMenuItem(name, callback, svg) {
        const li = document.createElement("li");
        li.className = "at-context-menu__item";
        li.textContent = name;
        li.setAttribute("tabindex", "0");
        li.addEventListener("click", ()=>{
            this.hide();
            callback();
        });
        li.addEventListener("keyup", (event)=>{
            if (event.key.toLowerCase() === "enter") {
                this.hide();
                callback();
            }
        });
        const icon = document.createElement("span");
        icon.className = "at-context-menu__icon";
        icon.innerHTML = svg;
        li.insertAdjacentElement("afterbegin", icon);
        this.menu.appendChild(li);
    }
    show(event) {
        this.menu.style.left = `${event.clientX}px`;
        this.menu.style.top = `${event.clientY}px`;
        this.menu.classList.add("at-context-menu--show");
        this.menu.focus();
    }
    hide() {
        this.menu.classList.remove("at-context-menu--show");
    }
}
exports.default = ContextMenu;

},{"../helpers/TrapFocus":"2nbVV","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","../helpers/Icons":"7YvtL"}]},["iHUTf","8SNpy"], "8SNpy", "parcelRequire5c84")

</script>
    </body>
</html>
